services:
  # Backend API Server
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: meetrub-backend
    ports:
      - "5000:5000"  # Map host port 5000 to container port 5000
    env_file:
      - ./.env
    volumes:
      # Mount logs directory to persist logs outside container
      - ./backend/logs:/app/logs
    networks:
      - meetrub-network
    depends_on:
      rabbitmq:
        condition: service_healthy  # Wait for RabbitMQ to be healthy
    restart: unless-stopped  # Restart container unless manually stopped
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:5000/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Notification Worker Service (Email, In-App, etc.)
  worker:
    build:
      context: ./worker
      dockerfile: Dockerfile
    container_name: meetrub-worker
    env_file:
      - ./.env
    networks:
      - meetrub-network
    depends_on:
      rabbitmq:
        condition: service_healthy  # Wait for RabbitMQ to be healthy
    restart: unless-stopped
    # Workers typically don't expose ports, but can log to stdout

  # Chat Server - WebSocket server for real-time messaging
  chat-server:
    build:
      context: ./chat-server
      dockerfile: Dockerfile
    container_name: meetrub-chat
    ports:
      - "4000:4000"  # Map host port 4000 to container port 4000
    env_file:
      - ./.env
    environment:
      - PORT=4000
    volumes:
      # Mount logs directory to persist logs outside container
      - ./chat-server/logs:/app/logs
    networks:
      - meetrub-network
    depends_on:
      rabbitmq:
        condition: service_healthy  # Wait for RabbitMQ to be healthy
      redis:
        condition: service_healthy  # Wait for Redis to be healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:4000/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # RabbitMQ - Message Queue for notifications
  rabbitmq:
    image: rabbitmq:3.13-management-alpine
    container_name: meetrub-rabbitmq
    ports:
      - "5672:5672"   # AMQP protocol port
      - "15672:15672" # Management UI (http://localhost:15672)
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    volumes:
      - rabbitmq-data:/var/lib/rabbitmq  # Persist RabbitMQ data
    networks:
      - meetrub-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # Redis - In-memory data store for caching and sessions
  redis:
    image: redis:7-alpine
    container_name: meetrub-redis
    ports:
      - "6379:6379"
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis-data:/data
    networks:
      - meetrub-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # PostgreSQL Database (uncomment if you need it)
  # postgres:
  #   image: postgres:15-alpine
  #   container_name: meetrub-postgres
  #   environment:
  #     POSTGRES_USER: ${POSTGRES_USER:-meetrub}
  #     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-changeme}
  #     POSTGRES_DB: ${POSTGRES_DB:-meetrub}
  #   ports:
  #     - "5432:5432"
  #   volumes:
  #     - postgres-data:/var/lib/postgresql/data
  #   networks:
  #     - meetrub-network
  #   restart: unless-stopped
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-meetrub}"]
  #     interval: 10s
  #     timeout: 5s
  #     retries: 5

# Define volumes for data persistence
volumes:
  rabbitmq-data:
    driver: local
  redis-data:
    driver: local
  # postgres-data:  # Uncomment if using PostgreSQL
  #   driver: local

# Define network for inter-container communication
networks:
  meetrub-network:
    driver: bridge